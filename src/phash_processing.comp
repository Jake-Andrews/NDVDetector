#version 450
#extension GL_KHR_shader_subgroup_basic : enable // Example extension if needed

// Input: Decoded Y-plane (assuming imported as R8_UNORM)
layout(set = 0, binding = 0) uniform sampler2D inputYPlane;

// Output: 32x32 float image for pHash processing
layout(set = 0, binding = 1, r32f) uniform image2D outputImage; // R32F format

// Push constants for input dimensions (optional, could use UBO)
layout(push_constant) uniform PushConstants {
    int inputWidth;
    int inputHeight;
} pushConstants;

// Local workgroup size (adjust as needed for performance)
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    // Get global invocation ID (pixel coordinate in output 32x32 image)
    ivec2 outCoords = ivec2(gl_GlobalInvocationID.xy);

    // Check bounds for output image (32x32)
    if (outCoords.x >= 32 || outCoords.y >= 32) {
        return;
    }

    // --- Step 1: Calculate corresponding coordinates in the input image ---
    // Use center sampling for resizing. texelFetch needs integer coordinates.
    // Calculate normalized coords first.
    vec2 inNormCoords = (vec2(outCoords) + 0.5) / 32.0;
    vec2 inCoordsCenter = inNormCoords * vec2(pushConstants.inputWidth, pushConstants.inputHeight);


    // --- Step 2: Apply 7x7 Mean Filter around the calculated input coordinate ---
    float sum = 0.0f;
    const int filterRadius = 3; // 7x7 filter -> radius 3
    const int filterSize = 49; // 7 * 7

    for (int j = -filterRadius; j <= filterRadius; ++j) {
        for (int i = -filterRadius; i <= filterRadius; ++i) {
            // Calculate integer coordinates for fetching this texel
            ivec2 currentCoords = ivec2(round(inCoordsCenter + vec2(i, j)));

            // Clamp coordinates to image bounds explicitly for texelFetch
            currentCoords.x = clamp(currentCoords.x, 0, pushConstants.inputWidth - 1);
            currentCoords.y = clamp(currentCoords.y, 0, pushConstants.inputHeight - 1);

            // Fetch the Luminance (Y) value
            // Assuming input texture format is R8_UNORM, fetch returns vec4 (r,0,0,1)
            // Convert the normalized value [0,1] back to ~[0,255] range expected by pHash float input
            sum += texture(inputYPlane, currentCoords).r * 255.0f;
        }
    }

    // Calculate the average
    float averageValue = sum / float(filterSize);

    // --- Step 3: Write the result to the output 32x32 image ---
    imageStore(outputImage, outCoords, vec4(averageValue, 0.0f, 0.0f, 1.0f));
}
